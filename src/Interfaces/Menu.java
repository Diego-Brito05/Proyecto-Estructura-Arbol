/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JFrame.java to edit this template
 */
package Interfaces;

import EDD.HashTable;
import Arbol.Arbol;
import Arbol.Persona;
import EDD.ListaPersona;
import EDD.NodoPersona;
import LectorJson.LectorJson;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.awt.geom.Point2D;
import java.io.File;
import javax.swing.JFrame;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import org.graphstream.graph.Edge;
import org.graphstream.graph.Graph;
import org.graphstream.graph.Node;
import org.graphstream.graph.implementations.MultiGraph;
import org.graphstream.ui.swing_viewer.SwingViewer;
import org.graphstream.ui.swing_viewer.ViewPanel;
import org.graphstream.ui.view.Viewer;

/**
 *
 * @author Diego
 */
public class Menu extends javax.swing.JFrame {
    private Arbol arbol;
    private static File archivo;
    private static Graph familia;
    private static HashTable hashtable;
    private static String estiloNodo = 
            "size: 20px; " + 
            "shape: diamond; " + 
            "fill-color: blue; " + 
            "text-size: 20; " +  
            "text-alignment: at-right; " + 
            "shadow-mode: plain; " + 
            "shadow-color: black; " + 
            "shadow-width: 5px; " + 
            "shadow-offset: 0px; " + 
            "text-offset: 5px, 5px;";
    /**
     * Creates new form Menuu
     */
    public Menu() {
        this.setVisible(true);
        initComponents();
        this.setLocationRelativeTo(null);
        this.arbol = null;
        this.hashtable = null;
        this.archivo = null;
        this.familia = null;
        this.setLocationRelativeTo(null);
        }
    
    public Arbol getArbol() {
        return arbol;
    }

    public void setArbol(Arbol arbol) {
        this.arbol = arbol;
    }

    public File getArchivo() {
        return archivo;
    }

    public void setArchivo(File archivo) {
        this.archivo = archivo;
    }

    public Graph getFamilia(){
        return familia;
    }
    


    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        MostrarGrafo = new javax.swing.JButton();
        CargaArchivo = new javax.swing.JButton();
        jButton1 = new javax.swing.JButton();
        Mant = new javax.swing.JTextField();
        jLabel1 = new javax.swing.JLabel();
        BuscarAntepasados = new javax.swing.JButton();
        mgenes = new javax.swing.JButton();
        gene = new javax.swing.JTextField();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        PersonaBuscar = new javax.swing.JTextField();
        jLabel5 = new javax.swing.JLabel();
        BuscarPersona = new javax.swing.JButton();
        TituloBuscar = new javax.swing.JTextField();
        jLabel2 = new javax.swing.JLabel();
        BuscarTitulo = new javax.swing.JButton();
        jLabel6 = new javax.swing.JLabel();
        jLabel7 = new javax.swing.JLabel();
        jLabel8 = new javax.swing.JLabel();
        Binf = new javax.swing.JButton();
        infop = new javax.swing.JTextField();
        jLabel9 = new javax.swing.JLabel();
        jLabel10 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jPanel1.setBackground(new java.awt.Color(204, 204, 255));
        jPanel1.setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

        MostrarGrafo.setBackground(new java.awt.Color(153, 51, 255));
        MostrarGrafo.setText("MOSTRAR GRAFO");
        MostrarGrafo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                MostrarGrafoActionPerformed(evt);
            }
        });
        jPanel1.add(MostrarGrafo, new org.netbeans.lib.awtextra.AbsoluteConstraints(260, 440, 280, -1));

        CargaArchivo.setBackground(new java.awt.Color(153, 51, 255));
        CargaArchivo.setText("CARGAR ARCHIVO");
        CargaArchivo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                CargaArchivoActionPerformed(evt);
            }
        });
        jPanel1.add(CargaArchivo, new org.netbeans.lib.awtextra.AbsoluteConstraints(260, 400, 280, -1));

        jButton1.setBackground(new java.awt.Color(153, 51, 255));
        jButton1.setText("X");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });
        jPanel1.add(jButton1, new org.netbeans.lib.awtextra.AbsoluteConstraints(730, 480, 90, 20));

        Mant.setBackground(new java.awt.Color(204, 204, 204));
        jPanel1.add(Mant, new org.netbeans.lib.awtextra.AbsoluteConstraints(630, 170, 150, -1));

        jLabel1.setFont(new java.awt.Font("Segoe UI", 1, 14)); // NOI18N
        jLabel1.setText("Buscar Titulo");
        jPanel1.add(jLabel1, new org.netbeans.lib.awtextra.AbsoluteConstraints(110, 10, -1, -1));

        BuscarAntepasados.setBackground(new java.awt.Color(153, 51, 255));
        BuscarAntepasados.setText("Buscar");
        BuscarAntepasados.setToolTipText("");
        BuscarAntepasados.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                BuscarAntepasadosActionPerformed(evt);
            }
        });
        jPanel1.add(BuscarAntepasados, new org.netbeans.lib.awtextra.AbsoluteConstraints(670, 200, -1, -1));

        mgenes.setBackground(new java.awt.Color(153, 51, 255));
        mgenes.setText("Generacion");
        mgenes.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                mgenesActionPerformed(evt);
            }
        });
        jPanel1.add(mgenes, new org.netbeans.lib.awtextra.AbsoluteConstraints(650, 90, -1, -1));

        gene.setBackground(new java.awt.Color(204, 204, 204));
        gene.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                geneActionPerformed(evt);
            }
        });
        jPanel1.add(gene, new org.netbeans.lib.awtextra.AbsoluteConstraints(620, 60, 150, -1));

        jLabel3.setFont(new java.awt.Font("Segoe UI", 1, 14)); // NOI18N
        jLabel3.setText("Buscar Persona");
        jPanel1.add(jLabel3, new org.netbeans.lib.awtextra.AbsoluteConstraints(60, 340, -1, -1));

        jLabel4.setFont(new java.awt.Font("Segoe UI", 1, 14)); // NOI18N
        jLabel4.setText("Mostrar Generacion");
        jPanel1.add(jLabel4, new org.netbeans.lib.awtextra.AbsoluteConstraints(630, 20, -1, 20));

        PersonaBuscar.setBackground(new java.awt.Color(204, 204, 204));
        PersonaBuscar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                PersonaBuscarActionPerformed(evt);
            }
        });
        jPanel1.add(PersonaBuscar, new org.netbeans.lib.awtextra.AbsoluteConstraints(30, 390, 150, -1));

        jLabel5.setFont(new java.awt.Font("Segoe UI", 1, 14)); // NOI18N
        jLabel5.setText("Mostrar Antepasados");
        jPanel1.add(jLabel5, new org.netbeans.lib.awtextra.AbsoluteConstraints(630, 130, -1, 20));

        BuscarPersona.setBackground(new java.awt.Color(153, 51, 255));
        BuscarPersona.setText("Buscar Persona");
        BuscarPersona.setToolTipText("");
        BuscarPersona.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                BuscarPersonaActionPerformed(evt);
            }
        });
        jPanel1.add(BuscarPersona, new org.netbeans.lib.awtextra.AbsoluteConstraints(50, 420, -1, -1));

        TituloBuscar.setBackground(new java.awt.Color(204, 204, 204));
        TituloBuscar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                TituloBuscarActionPerformed(evt);
            }
        });
        jPanel1.add(TituloBuscar, new org.netbeans.lib.awtextra.AbsoluteConstraints(10, 60, 370, -1));

        jLabel2.setText("Escriba el nombre de la persona");
        jPanel1.add(jLabel2, new org.netbeans.lib.awtextra.AbsoluteConstraints(620, 150, -1, -1));

        BuscarTitulo.setBackground(new java.awt.Color(153, 51, 255));
        BuscarTitulo.setText("Buscar Personas");
        BuscarTitulo.setToolTipText("");
        BuscarTitulo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                BuscarTituloActionPerformed(evt);
            }
        });
        jPanel1.add(BuscarTitulo, new org.netbeans.lib.awtextra.AbsoluteConstraints(130, 100, -1, -1));

        jLabel6.setText("Ej: King of the Andals and the First Men, Lord of the Seven Kingdoms ");
        jPanel1.add(jLabel6, new org.netbeans.lib.awtextra.AbsoluteConstraints(10, 40, -1, -1));

        jLabel7.setText("Mostrara su descendencia");
        jPanel1.add(jLabel7, new org.netbeans.lib.awtextra.AbsoluteConstraints(40, 370, -1, -1));

        jLabel8.setText("Escriba el numero de la generacion");
        jPanel1.add(jLabel8, new org.netbeans.lib.awtextra.AbsoluteConstraints(600, 40, -1, -1));

        Binf.setBackground(new java.awt.Color(153, 51, 255));
        Binf.setText("Buscar Info");
        Binf.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                BinfActionPerformed(evt);
            }
        });
        jPanel1.add(Binf, new org.netbeans.lib.awtextra.AbsoluteConstraints(670, 380, -1, -1));

        infop.setBackground(new java.awt.Color(204, 204, 204));
        jPanel1.add(infop, new org.netbeans.lib.awtextra.AbsoluteConstraints(640, 340, 140, -1));

        jLabel9.setFont(new java.awt.Font("Segoe UI", 1, 14)); // NOI18N
        jLabel9.setText("Mostrar Informacion");
        jPanel1.add(jLabel9, new org.netbeans.lib.awtextra.AbsoluteConstraints(640, 300, -1, -1));

        jLabel10.setText("Escriba el Nombre de la Persona ");
        jPanel1.add(jLabel10, new org.netbeans.lib.awtextra.AbsoluteConstraints(620, 320, -1, -1));

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel1, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents
    

    
    private void CargaArchivoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_CargaArchivoActionPerformed
    LectorJson LeerJson =new LectorJson();
        HashTable hashtable= new HashTable(); 
        ListaPersona personas = new ListaPersona();
        File archivo = LeerJson.LecturaJson(personas);
        setArchivo(archivo);
        setArbol(null);
        this.arbol=(Arbol.crearArbolDesdeLista(personas));
        this.arbol.validarYCompletarHijosPreorden(this.arbol);
        hashtable.putArbol(this.arbol);
        setHashtable(hashtable);
        this.hashtable = hashtable;
        setArbol(arbol);
        JOptionPane.showMessageDialog(null, "Se ha cargado el archivo");
        
    }//GEN-LAST:event_CargaArchivoActionPerformed
    
    /*
    Esta funcion se encarga de crear un Jpanel, para luego añadirlo a un SwingViewer que tiene el grafo para luego mostrarlo
    */
    public void displayGraph(Graph graph2) {
    // Crear la ventana para mostrar el grafo
    JFrame frame = new JFrame();
    frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);

    // Crear un panel con un diseño personalizado
    JPanel panel = new JPanel(new GridLayout()) {
        @Override
        public Dimension getPreferredSize() {
            return new Dimension(1600, 960);  // Ajusta el tamaño de la ventana
        }
    };

    frame.setSize(panel.getWidth(), panel.getHeight());

    // Crear el Viewer para mostrar el grafo
    Viewer viewer = new SwingViewer(graph2, Viewer.ThreadingModel.GRAPH_IN_GUI_THREAD);

    // Aplicar el layout antes de la visualización
    graph2.setAttribute("ui.layout", "FruchtermanReingold");
    viewer.enableAutoLayout();

    // Verificar que el layout haya aplicado y esperar un poco para que las coordenadas estén disponibles
    
    try {
        Thread.sleep(2000);  
    } catch (InterruptedException e) {
    }
   
    
    

    // Obtener el panel de visualización y agregarlo al panel principal
    ViewPanel viewPanel = (ViewPanel) viewer.addDefaultView(false);
    panel.add(viewPanel);
    frame.add(panel);

    frame.pack();  // Ajustar tamaño del frame según el contenido
    frame.setLocationRelativeTo(null);  // Centrar la ventana en la pantalla
    frame.setVisible(true);
    viewPanel.setFocusable(true);
    viewPanel.requestFocusInWindow();
    viewPanel.enableMouseOptions();

    // Agregar controlador de eventos para capturar clics sobre los nodos
     viewPanel.addMouseListener(new java.awt.event.MouseAdapter() {
        @Override
        public void mousePressed(java.awt.event.MouseEvent e) {
            if (e.getButton() == java.awt.event.MouseEvent.BUTTON1) {  // Botón izquierdo del ratón
                // Obtener las coordenadas del clic en la pantalla
                int x = e.getX();
                int y = e.getY();
                System.out.println(x +" "+y);
                viewer.enableAutoLayout();

                // Iterar sobre todos los nodos del grafo para verificar si el clic es sobre un nodo
                for (Node node : graph2) {
                    // Obtener las coordenadas del nodo en el sistema del layout
                    Double nodeX = node.getAttribute("x", Double.class);
                    Double nodeY = node.getAttribute("y", Double.class);
            
                    if (nodeX != null && nodeY != null) {
                        // Aquí comparamos las coordenadas del clic con las coordenadas del nodo
                        // Transformamos las coordenadas del nodo a las de la pantalla
                        // Debemos considerar el escalado y la traslación en la visualización

                        // Verificar si el clic está dentro de un radio de distancia del nodo
                        double nodeRadius = 20;  // Ajustar el tamaño del nodo si es necesario

                        // Convertimos las coordenadas del nodo en coordenadas de pantalla
                        // Esta parte depende de cómo esté configurada la visualización,
                        // si no hay un método directo para obtener la posición en pantalla,
                        // se hace una simple aproximación.
                        double screenX = nodeX * 100 + 400;  // Esto puede necesitar ajustes
                        double screenY = nodeY * 100 + 200;  // Ajuste para centrar el grafo en la ventana

                        // Cálculo de distancia entre el clic y el nodo
                        double distance = Math.sqrt(Math.pow(x - screenX, 2) + Math.pow(y - screenY, 2));

                        if (distance < nodeRadius) {
                            // Si el clic es sobre el nodo
                            Persona persona = (Persona) node.getAttribute("persona");

                            if (persona != null) {
                                String hijos = persona.getHijos() != null ? String.join(", ", persona.getHijos()) : "No tiene hijos";
                                String message = "Información del Nodo:\n" +
                                                 "Nombre: " + persona.getNombre() + "\n" +
                                                 "Numeral: " + persona.getNumeral() + "\n" +
                                                 "Hijos: " + hijos;

                                // Mostrar un JOptionPane con los detalles del nodo
                                JOptionPane.showMessageDialog(null, message, "Detalle del Nodo", JOptionPane.INFORMATION_MESSAGE);
                            } else {
                                System.out.println("El nodo no tiene un atributo 'persona'.");
                            }
                        }
                    } else {
                        System.out.println("El nodo " + node.getId() + " no tiene coordenadas.");
                    }
                }
            }
        }
    });
}
    
    /*
    Este metodo se encarga de crear el grafo con la libreria graphstream para luego ser mostrado
    
    */
    
    private void MostrarGrafoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_MostrarGrafoActionPerformed
    if (this.arbol==null){
            JOptionPane.showMessageDialog(null, "No se ha cargado ningun archivo");
        }
        else{
        try{           
            Graph Familia = new MultiGraph("Familia Real");
            System.setProperty("org.graphstream.ui", "swing");
            System.setProperty("gs.ui.renderer", "org.graphstream.ui.j2dviewer.J2DGraphRenderer");
            setFamilia(Familia);
            agregarPersonasAlGrafo(getArbol(),getFamilia());
            crearRelaciones(getFamilia());
            Familia.setAttribute("ui.layout", "FruchtermanReingold");
            
            displayGraph(getFamilia());
        
        }
        catch(Exception err){
                    JOptionPane.showMessageDialog(null, err);
            }
        }
    }//GEN-LAST:event_MostrarGrafoActionPerformed

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        this.dispose();
    }//GEN-LAST:event_jButton1ActionPerformed

    private void BuscarAntepasadosActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_BuscarAntepasadosActionPerformed
        // TODO add your handling code here:
         String ante = Mant.getText();

    // Buscar la persona en el árbol genealógico
    Persona personaBuscada = buscarPersonaPorNombrePer(ante);

    if (personaBuscada == null) {
        JOptionPane.showMessageDialog(null, "Persona no encontrada.");
        return;
    }

    // Llamar al método que se encarga de crear el grafo y agregar los antepasados
    agregarAntepasadosAlGrafo(personaBuscada, ante);
           
    }//GEN-LAST:event_BuscarAntepasadosActionPerformed

     private void agregarAntepasadosAlGrafo(Persona persona, String ante) {
    // Crear un nuevo grafo para mostrar los antepasados
    Graph grafoAntepasados = new MultiGraph("Antepasados de " + ante);
    grafoAntepasados.setAttribute("ui.stylesheet", "node { fill-color: blue; size: 20px; }");

    // Crear el HashTable para almacenar las personas procesadas
    HashTable personasProcesadas = new HashTable();

    // Recursivamente agregar a la persona y sus antepasados directos al grafo
    agregarAntepasadosAlGrafoRecursivo(persona, grafoAntepasados, null, personasProcesadas);

    // Mostrar el grafo en una nueva ventana
    displayGraph(grafoAntepasados);
}

private void agregarAntepasadosAlGrafoRecursivo(Persona persona, Graph grafo, Node padre, HashTable personasProcesadas) {
    if (persona == null) return;  // Si la persona no existe, detener la recursión

    // Crear un identificador único para este nodo basado en la persona
    String nodoId = persona.getNombre() + persona.getNumeral();

    // Verificar si esta persona ya ha sido procesada
    if (personasProcesadas.containsKey(nodoId)) {
        return;  // Si ya fue procesada, detener la recursión
    }

    // Marcar esta persona como procesada
    personasProcesadas.put(nodoId, persona);

    // Crear el nodo si no existe
    if (grafo.getNode(nodoId) == null) {
        Node nodo = grafo.addNode(nodoId);
        nodo.setAttribute("ui.label", persona.getNombre() + " " + persona.getNumeral());
    }

    // Si existe un padre, agregar una arista entre el padre y este nodo
    if (padre != null) {
        String edgeId = padre.getId() + "-" + nodoId;
        if (grafo.getEdge(edgeId) == null) {
            grafo.addEdge(edgeId, padre.getId(), nodoId);
        }
    }
}




 
    private void mgenesActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_mgenesActionPerformed
        // TODO add your handling code here:
       String geng = gene.getText();

    try {
        // Convertir la entrada a un número entero
        int numeroGeneracion = Integer.parseInt(geng);

        // Validar que el número sea positivo
        if (numeroGeneracion < 0) {
            JOptionPane.showMessageDialog(this, "Por favor, ingrese un número de generación válido (mayor o igual a 0).", 
                "Error", JOptionPane.ERROR_MESSAGE);
            return;
        }

        // Verificar si el árbol está cargado
        if (this.arbol == null) {
            JOptionPane.showMessageDialog(this, "No se ha cargado ningún archivo o el árbol está vacío.", 
                "Error", JOptionPane.ERROR_MESSAGE);
            return;
        }

        // Obtener las personas de la generación
        ListaPersona generacion = obtenerPersonasPorGeneracion(this.arbol, numeroGeneracion);

        // Construir el mensaje para mostrar en el JOptionPane
        StringBuilder mensaje = new StringBuilder();
        mensaje.append("Generación ").append(numeroGeneracion).append(":\n\n");

        NodoPersona nodoActual = generacion.getCabeza();
        if (nodoActual == null) {
            mensaje.append("No hay personas en esta generación.");
        } else {
            while (nodoActual != null) {
                Persona persona = nodoActual.persona;
                mensaje.append("- ")
                       .append(persona.getNombre())
                       .append(" ")
                       .append(persona.getNumeral())
                       .append("\n");
                nodoActual = nodoActual.siguiente;
            }
        }

        // Mostrar el mensaje en un JOptionPane
        JOptionPane.showMessageDialog(null, mensaje.toString(), 
            "Personas de la generación " + numeroGeneracion, 
            JOptionPane.INFORMATION_MESSAGE);

    } catch (NumberFormatException e) {
        // Manejar errores si el texto no es un número válido
        JOptionPane.showMessageDialog(this, "Por favor, ingrese un número de generación válido.", 
            "Error", JOptionPane.ERROR_MESSAGE);
    }
        
    }//GEN-LAST:event_mgenesActionPerformed

    private void geneActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_geneActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_geneActionPerformed

    private void PersonaBuscarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_PersonaBuscarActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_PersonaBuscarActionPerformed

    private void BuscarPersonaActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_BuscarPersonaActionPerformed
        String NombrePersona = PersonaBuscar.getText();
        if (NombrePersona== null || getHashtable() == null){
            JOptionPane.showMessageDialog(this, "No se encontro a la persona.", 
            "Error", JOptionPane.ERROR_MESSAGE);
        }else{
            int indice= getHashtable().buscarIndice(NombrePersona);
            if (indice!= -1){
                ListaPersona lPersonas = getHashtable().getTabla()[indice];
                NodoPersona actual= lPersonas.getCabeza();
                int contador = 1;
                String info = "Escriba el indice de la persona buscada" + "\n" + "\n";
                while(actual != null){
                    Persona P= actual.getPersona();
                    String nombreP = P.getNombre();
                    String MoteP = P.getMote();
                    String PadreP = P.getPadre();
                    info = info + contador +"- " + "Nombre: " + nombreP + "; Mote: " + MoteP + "; Hijo de: " + PadreP + "\n";
                    actual = actual.siguiente;
                    contador ++;
                }
                String respuesta = JOptionPane.showInputDialog(info);
                if(esNumerico(respuesta)){
                    int respN= Integer.parseInt(respuesta);
                    actual = lPersonas.getCabeza();
                    contador=1;
                    while(contador != respN){
                        actual= actual.siguiente;
                        contador++;
                    }
                    if (actual != null){
                        Persona per= actual.getPersona();
                        Arbol nodoPer= buscarNodoPorPersona(this.arbol, per);
                        Graph sucesores = new MultiGraph("Sucesores");
                        System.setProperty("org.graphstream.ui", "swing");
                        System.setProperty("gs.ui.renderer", "org.graphstream.ui.j2dviewer.J2DGraphRenderer");
                        setFamilia(sucesores);
                        agregarPersonasAlGrafo(nodoPer,sucesores);
                        crearRelaciones(sucesores);
                        sucesores.setAttribute("ui.layout", "FruchtermanReingold");

                        displayGraph(getFamilia());
                    }else{
                        JOptionPane.showMessageDialog(this, "No se encontro a la persona.", 
                        "Error", JOptionPane.ERROR_MESSAGE);
                    }
                
            }else{
                  JOptionPane.showMessageDialog(this, "No se encontro a la persona.", 
                   "Error", JOptionPane.ERROR_MESSAGE);  
                }

                    
            }else{
                JOptionPane.showMessageDialog(this, "No se encontro a la persona.", 
            "Error", JOptionPane.ERROR_MESSAGE);
            }
        }
            
    }//GEN-LAST:event_BuscarPersonaActionPerformed

    private void TituloBuscarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_TituloBuscarActionPerformed
       
    }//GEN-LAST:event_TituloBuscarActionPerformed

    private void BuscarTituloActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_BuscarTituloActionPerformed
        String TituloBusc = TituloBuscar.getText();
        if (TituloBusc== null || getHashtable() == null){
            JOptionPane.showMessageDialog(this, "No se encontro a la persona.", 
            "Error", JOptionPane.ERROR_MESSAGE);
        }else{
            ListaPersona Personas = new ListaPersona();
            buscarPorTituloEnLista(this.arbol, TituloBusc,Personas);
            NodoPersona actual= Personas.getCabeza();
                int contador = 1;
                String info = "Escriba el indice de la persona buscada" + "\n" + "\n";
                while(actual != null){
                    Persona P= actual.getPersona();
                    String nombreP = P.getNombre();
                    String MoteP = P.getMote();
                    String PadreP = P.getPadre();
                    info = info + contador +"- " + "Nombre: " + nombreP + "; Mote: " + MoteP + "; Hijo de: " + PadreP + "\n";
                    actual = actual.siguiente;
                    contador ++;
                }
                String respuesta = JOptionPane.showInputDialog(info);
                if(esNumerico(respuesta)){
                    int respN= Integer.parseInt(respuesta);
                    actual = Personas.getCabeza();
                    contador=1;
                    while(contador != respN){
                        actual= actual.siguiente;
                        contador++;
                    }
                    if (actual != null){
                        Persona per= actual.getPersona();
                        String infoper = "Nombre: " + per.getNombre() + "\n" + "Numeral: " + per.getNumeral() + "\n" + "Mote: " + per.getMote() + "\n" + "Hijo de : " + per.getPadre() + "\n" + "Titulo: " + per.getTitulo() + "\n" + "Color de ojos: " + per.getOjos() + "\n" + "Color de pelo: " + per.getPelo() + "\n";
                        JOptionPane.showMessageDialog(null, infoper);
                    }else{
                        JOptionPane.showMessageDialog(this, "No se encontro a la persona.", 
                        "Error", JOptionPane.ERROR_MESSAGE);
                    }
                
            }else{
                  JOptionPane.showMessageDialog(this, "No se encontro a la persona.", 
                   "Error", JOptionPane.ERROR_MESSAGE);  
                }
            
        }
    }//GEN-LAST:event_BuscarTituloActionPerformed

    private void BinfActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_BinfActionPerformed
        // TODO add your handling code here:
        String padreInfo = Binf.getText().trim();  // Lo que el usuario ingresa

    // Verifica si el HashTable está inicializado
    if (this.hashtable == null) {
        JOptionPane.showMessageDialog(this, "Debe cargar un archivo primero.", "Error", JOptionPane.ERROR_MESSAGE);
        return;
    }

    // Verifica si el campo de búsqueda está vacío
    if (padreInfo.isEmpty()) {
        JOptionPane.showMessageDialog(this, "Por favor, ingrese un nombre para buscar.", "Error", JOptionPane.ERROR_MESSAGE);
        return;
    }

    // Buscar las personas en el HashTable usando el primer nombre como clave
    Persona[] personasEncontradas = this.hashtable.get(padreInfo); // Esto usa el primer nombre como clave

    // Si no se encuentran personas asociadas con la clave, mostrar mensaje
    if (personasEncontradas.length == 0) {
        JOptionPane.showMessageDialog(this, "No se encontraron personas con ese nombre.", "Resultado de Búsqueda", JOptionPane.INFORMATION_MESSAGE);
    } else {
        // Si encontramos personas, mostrar los detalles en un JOptionPane
        StringBuilder mensaje = new StringBuilder();
        mensaje.append("Personas encontradas:\n");

        for (Persona persona : personasEncontradas) {
            mensaje.append("\n----------------------------------\n");
            mensaje.append("Nombre: ").append(persona.getNombre()).append("\n");
            mensaje.append("Numeral: ").append(persona.getNumeral()).append("\n");
            mensaje.append("Padre: ").append(persona.getPadre()).append("\n");
            mensaje.append("Mote: ").append(persona.getMote()).append("\n");
            mensaje.append("Título: ").append(persona.getTitulo()).append("\n");
            mensaje.append("Ojos: ").append(persona.getOjos()).append("\n");
            mensaje.append("Pelo: ").append(persona.getPelo()).append("\n");
            mensaje.append("Hijos: ").append(String.join(", ", persona.getHijos())).append("\n");
        }

        // Mostrar la información en un JOptionPane
        JOptionPane.showMessageDialog(this, mensaje.toString(), "Resultado de Búsqueda", JOptionPane.INFORMATION_MESSAGE);
    }

        
        
    }//GEN-LAST:event_BinfActionPerformed
    
   
    
    private ListaPersona obtenerPersonasPorGeneracion(Arbol nodoActual, int numeroGeneracion) {
    ListaPersona listaGeneracion = new ListaPersona();

    if (nodoActual == null) {
        return listaGeneracion; // Devuelve una lista vacía si el árbol está vacío
    }

    // Método auxiliar para recorrer el árbol y agregar personas a la lista
    obtenerGeneracionRecursivo(nodoActual, numeroGeneracion, 0, listaGeneracion);

    return listaGeneracion;
}

private void obtenerGeneracionRecursivo(Arbol nodoActual, int numeroGeneracion, int nivelActual, ListaPersona listaGeneracion) {
    if (nodoActual == null) {
        return;
    }

    // Si el nivel actual coincide con la generación buscada, agrega la persona a la lista
    if (nivelActual == numeroGeneracion) {
        listaGeneracion.agregar(nodoActual.getValor());
    }

    // Recorrer los hijos del nodo actual
    Arbol hijoActual = nodoActual.getPrimerHijo();
    while (hijoActual != null) {
        obtenerGeneracionRecursivo(hijoActual, numeroGeneracion, nivelActual + 1, listaGeneracion);
        hijoActual = hijoActual.getHermanoDerecho();
    }
}

    
     
    
    private Persona buscarPersonaPorNombrePer(String nombre) {
    // Aquí debes implementar la lógica para buscar a la persona en el árbol
    // Puedes usar un recorrido en el árbol para encontrar la persona
    Persona persona = buscarPersonaEnArbol(getArbol(), nombre);
    if (persona != null) {
        System.out.println("Persona encontrada: " + persona.getNombre()); // Log de depuración
    } else {
        System.out.println("Persona no encontrada: " + nombre); // Log de depuración
    }
    return persona;
}
    
     private Persona buscarPersonaEnArbol(Arbol nodoActual, String nombre) {
    // Si el nodo actual es null, no hay nada que hacer
    if (nodoActual == null) {
        return null;
    }

    // Obtener la persona del nodo actual
    Persona personaActual = nodoActual.getValor();

    // Verificar si el nombre de la persona actual coincide con el nombre buscado
    if (personaActual.getNombre().equalsIgnoreCase(nombre)) {
        return personaActual; // Si coincide, retornar la persona
    }

    // Recursivamente buscar en los hijos
    Arbol hijoActual = nodoActual.getPrimerHijo(); // Obtener el primer hijo
    while (hijoActual != null) {
        Persona resultado = buscarPersonaEnArbol(hijoActual, nombre);
        if (resultado != null) {
            return resultado; // Si se encontró en algún hijo, retornar el resultado
        }
        hijoActual = hijoActual.getHermanoDerecho(); // Continuar con el siguiente hermano
    }

    // Si no se encontró la persona en ningún nodo del árbol, devolver null
    return null;
}
    
    // Función para agregar un nodo al grafo, guardando en un de sus atributo el objeto Persona de cada uno
    public static void agregarPersona(Graph grafo, Persona persona) {
        if (!persona.getNombre().equalsIgnoreCase("No children")){
            // Crear el nodo con el nombre completo
            String nombre = persona.getNombre();
            String numeral = persona.getNumeral();
            String mote = persona.getMote();
            Node nodo = grafo.addNode(nombre+numeral+mote);

            // Asignar el ui.label como "nombre (sin apellido), numeral"
            String uiLabel = null;
            String[] nombrediv= persona.getNombre().split(" ");
            String nombreSinApellido = null;
            if (nombrediv.length>2){
                nombreSinApellido = nombrediv[0]+ " " + nombrediv[1];               
            }
            else{
                nombreSinApellido = nombrediv[0];
            }
            if (esNumerico(numeral)){
                uiLabel = (nombreSinApellido);
            }
            else{
                uiLabel = (nombreSinApellido + " " + numeral);
            }
            
            // Asignar el estilo al nodo
            nodo.setAttribute("ui.style", estiloNodo);
            
            nodo.setAttribute("ui.label", uiLabel);
            

            // Guardar el objeto Persona como atributo del nodo
            nodo.setAttribute("persona", persona);
            
            // Establecer el estilo para las aristas (si es necesario)
            String estiloArista = 
            "size: 20px; " + 
            "fill-color: black;";
            //  Asigna el estilo y la arista al nodo
            grafo.setAttribute("ui.style", "edge {" + estiloArista + "}");
            
        }
    }
    /*Esta funcion se encarga de al recibir un graph con los nodos ya creados, revisa su atributo persona y busca el Id asociado a su nodo para despues buscar el nodo de sus hijos 
        y hacer una arista entre ellos.    */
    public void crearRelaciones(Graph grafo) {
    for (Node nodo : grafo) {
        // Obtener el objeto Persona del nodo actual con un cast explícito
        Persona persona = (Persona) nodo.getAttribute("persona");

        // Verificar que no tenga solo "No children"
        if (persona.getHijos() != null && !persona.getHijos()[0].equals("No children")) {
            for (String hijoNombre : persona.getHijos()) {
                Arbol nodoPersona = buscarNodoPorPersona(getArbol(), persona);
                if (nodoPersona != null){
                    String[] hijoH = buscarHijosPorNombre(nodoPersona, hijoNombre);
                if (hijoH != null) {                       
                    // Crear las aristas dirigidas desde el nodo actual a cada hijo
                    String nodoId = nodo.getId();

                    for (String hijo : hijoH) { 
                        // Crear un ID único para cada arista basada en el nodo actual y el nombre completo del hijo
                        String aristaId = nodoId + "-" + hijo;

                        // Verificar si la arista ya existe antes de agregarla
                        if (grafo.getEdge(aristaId) == null) {
                            grafo.addEdge(aristaId, nodoId, hijo, true); // Agregar la arista al grafo
       
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    //Al recibir un nombre y pasarle el nodo de su padre, se encarga de buscar en cada uno de sus hijos para ver si el nombre coincide con el buscado, si es asi 
    //retorna un string de el nombre de la persona mas el numeral mas el mote, el cual es la forma en la que se guardan los Id de cada nodo
    public String[] buscarHijosPorNombre(Arbol nodoPadre, String nombreHijo) {
    // Primera pasada: Contar cuántos hijos coinciden
    int contador = 0;
    Arbol hijoActual = nodoPadre.getPrimerHijo();
    while (hijoActual != null) {
        Persona hijoPersona = hijoActual.getValor();
        String nombreHijoActual = hijoPersona.getNombre().split(" ")[0]; // Obtener solo el nombre sin apellido
        if (nombreHijoActual.equals(nombreHijo)) {
            contador++;
        }
        hijoActual = hijoActual.getHermanoDerecho();
    }

    // Si no se encontraron coincidencias, devolver null
    if (contador == 0) {
        return null;
    }

    // Segunda pasada: Almacenar los nombres en un arreglo
    String[] resultado = new String[contador];
    int indice = 0;
    hijoActual = nodoPadre.getPrimerHijo();
    while (hijoActual != null) {
        Persona hijoPersona = hijoActual.getValor();
        String nombreHijoActual = hijoPersona.getNombre().split(" ")[0];
        if (nombreHijoActual.equals(nombreHijo)) {
            resultado[indice] = hijoPersona.getNombre() + hijoPersona.getNumeral() + hijoPersona.getMote();
            indice++;
        }
        hijoActual = hijoActual.getHermanoDerecho();
    }

    return resultado;
    }
    
    /*Esta funcion se encarga de revisar en un arbol si la perosna buscada se encuentra en este arbol, revisando si su nombre y numeral coincide, en caso de que coincidan
    retorna el nodo del arbol en el que esta guardado de esa persona    
    */
    public Arbol buscarNodoPorPersona(Arbol nodoActual, Persona personaBuscada) {
    // Si el nodo actual es null, no hay nada que hacer
    if (nodoActual == null) {
        return null;
    }

    // Obtener la persona del nodo actual
    Persona personaActual = nodoActual.getValor();

    // Si la persona del nodo actual coincide con la persona buscada, devolver el nodo
    if (personaActual.getNombre().equals(personaBuscada.getNombre()) && personaActual.getNumeral().equals(personaBuscada.getNumeral()) ) {
        return nodoActual;
    }

    // Recursivamente buscar en los hijos del nodo actual
    Arbol hijoActual = nodoActual.getPrimerHijo();
    while (hijoActual != null) {
        Arbol resultado = buscarNodoPorPersona(hijoActual, personaBuscada);
        if (resultado != null) {
            return resultado; // Si la persona fue encontrada en algún hijo
        }
        hijoActual = hijoActual.getHermanoDerecho(); // Continuar con el siguiente hermano
    }

    // Si no se encuentra la persona en ningún nodo del árbol, devolver null
    return null;
    }
    
    //funcion que se encarga de recorrer todo el arbol y en cada nodo no nulo de el llama a la funcion agregarPersonas
    public static void agregarPersonasAlGrafo(Arbol nodoActual, Graph grafo) {
    // Si el nodo actual es null, no hacer nada
    if (nodoActual == null) {
        return;
    }

    // Obtener la persona asociada a este nodo
    Persona persona = nodoActual.getValor();

    // Llamar a la función para agregar el nodo al grafo
    agregarPersona(grafo, persona);

    // Recursivamente llamar para agregar los hijos
    Arbol hijoActual = nodoActual.getPrimerHijo(); // Obtener el primer hijo
    while (hijoActual != null) {
        // Llamar recursivamente para agregar el hijo al grafo
        agregarPersonasAlGrafo(hijoActual, grafo);
        hijoActual = hijoActual.getHermanoDerecho(); // Pasar al siguiente hermano
        }
    }
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Menu.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Menu.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Menu.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Menu.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Menu().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton Binf;
    private javax.swing.JButton BuscarAntepasados;
    private javax.swing.JButton BuscarPersona;
    private javax.swing.JButton BuscarTitulo;
    private javax.swing.JButton CargaArchivo;
    private javax.swing.JTextField Mant;
    private javax.swing.JButton MostrarGrafo;
    private javax.swing.JTextField PersonaBuscar;
    private javax.swing.JTextField TituloBuscar;
    private javax.swing.JTextField gene;
    private javax.swing.JTextField infop;
    private javax.swing.JButton jButton1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel10;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabel9;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JButton mgenes;
    // End of variables declaration//GEN-END:variables

    /**
     * @return the CargaArchivo
     */
    public javax.swing.JButton getCargaArchivo() {
        return CargaArchivo;
    }

    /**
     * @return the MostrarGrafo
     */
    public javax.swing.JButton getMostrarGrafo() {
        return MostrarGrafo;
    }

    /**
     * @return the jButton1
     */
    public javax.swing.JButton getjButton1() {
        return jButton1;
    }

    /**
     * @return the jPanel1
     */
    public javax.swing.JPanel getjPanel1() {
        return jPanel1;
    }

    /**
     * @param aFamilia the familia to set
     */
    public static void setFamilia(Graph aFamilia) {
        familia = aFamilia;
    }

    /**
     * @return the mySlylesheet
     */
    public static String getEstiloNodo() {
        return estiloNodo;
    }
    public static boolean esNumerico(String str) {
    try {
        Integer.parseInt(str.trim()); // Para números enteros
        return true;
    } catch (NumberFormatException e) {
        return false;
    }
    }

    /**
     * @return the hashtable
     */
    public static HashTable getHashtable() {
        return hashtable;
    }

    /**
     * @param aHashtable the hashtable to set
     */
    public static void setHashtable(HashTable aHashtable) {
        hashtable = aHashtable;
    }
    public static void buscarPorTituloEnLista(Arbol nodoActual, String titulo, ListaPersona listaResultado) {
    if (nodoActual == null) {
        return; // Si el nodo es nulo, no hay nada que hacer
    }

    // Obtener la persona asociada al nodo actual
    Persona persona = nodoActual.getValor();

    // Comprobar si el título de la persona coincide con el título buscado
    if (persona.getTitulo() != null && persona.getTitulo().equals(titulo)) {
        listaResultado.agregar(persona); // Agregar la persona a la lista
    }

    // Recorrer los hijos del nodo actual
    Arbol hijo = nodoActual.getPrimerHijo();
    while (hijo != null) {
        // Recursivamente buscar en los hijos
        buscarPorTituloEnLista(hijo, titulo, listaResultado);
        hijo = hijo.getHermanoDerecho(); // Pasar al siguiente hermano
    }
    }
    
    
}
